---
marp: true
---

# モデルとパフォーマンスの関係 in Unity

yusuke-ota

---

## 自己紹介

yusuke-ota

職種: 一般事務
言語: Rust, C#, Ruby, C++
最近の関心事: パフォーマンス, 低レイヤ, コンテナ

最近Quest用アプリケーション最適化やってます(CPU、GPUがつらい)

---

## 今回のお話し

Unityの最適化のグラフィック側の話を簡単にします。

本とかサイトを見ればわかるけど、その前の一歩になるかな？

---

### 対象

* Unityで最適化とかあんまりやったことがない人
* モデルがゲームのパフォーマンスにどのように影響するのか知りたい人

### 対象じゃない人

* 普段プロファイラとにらめっこしている人
* CPU側の処理を速くしたい人
* シェーダー書いている人

---

## 目次

1. Profiling
1. モデルのパフォーマンスに対する影響
1. まとめ
1. 次に読む
1. 参考文献

---

## Profiling

Unityのプロファイラの使い方、見方を話します。

* プロファイラ起動
* プロファイリング開始
* プロファイラの見方
* グラフィックの処理に時間がかかっている様子

---

### プロファイラ起動

<!-- プロファイラはここから開ける -->

---

### プロファイリング開始

---

### プロファイラの見方

---

### グラフィックの処理に時間がかかっている様子

---

## モデルのパフォーマンスに対する影響

レンダーの処理を追いながら、Blenderに関係のある部分を細かく見ていきます。

* 描画時の処理
* 実際の処理を見てみる
* カリング
* バッチング
* シェーダー

---

<!-- ### 用語 In Unity

バッチ:
// todo: 修正
CPUからGPUに送る計算処理の指示、及びその単位
世間一般で言われるドローコール

セットパスコール:
マテリアルやテクスチャが切り替わったときにGPUに出す指示のこと
ドローコールが増える要因の一つ

静的バッチング:
動かない、変化しないオブジェクトをあらかじめGPUにキャッシュするバッチング
変化しないので、都度メモリから読み込む必要がなく、その分早い
でもキャッシュする分GPUのメモリを消費する

動的バッチング:
動いたり、変化するオブジェクトもある程度まとめてしまおうというもの

--- -->

### 描画時の処理

![RenderProcess](./Images/RenderProcess.drawio.svg)

---

### 実際の処理を見てみる

#### FrameDebugger

あるフレームの中でバッチごとの画面描写を見ることができる機能。

バッチングされない理由も記載されるので、バッチングのデバックに便利。

---

#### 処理

<!-- todo -->

---

### カリング

---

#### フラスタムカリング

カメラに移っていない部分の描画を省く機能
Unityでは標準で働く

フラスタム=錐台(四角錐の上半分を切り落とした形状)
カメラの視認範囲がそういう形をしている

---

#### オクルージョンカリング

物体が被って見えない部分の描画を省く機能
**設定が必要**

オーバードローが多いほど効果がある(ex: 建物の中)
動作にCPUコストがかかるので、オーバードローが少ない時は切った方が良い

詳しい手順はこの辺
<https://light11.hatenadiary.com/entry/2019/11/11/220337>

---

### バッチング

* 静的バッチング
* 動的バッチング
* GPUインスタンシング

todo: 説明追加

---

#### バッチングされない原因

主な原因は**Set Pass Call**
使用するデータが変わる時、CPUからGPUにデータを送りなおす処理

具体的なタイミングは、

* 使うシェーダーが切り替わる
* 使うマテリアルが切り替わる
* 使うテクスチャが切り替わる
* 使うライトマップが切り替わる(ライトベイク時)

---

#### FrameDebuggerでバッチングされない原因を見てみる

todo: 画像

---

#### アトラス化

複数のテクスチャをまとめて一つのテクスチャにすること

* 同じマテリアルを使っている
* でもテクスチャが違うからバッチングされない

といったときに使うと良い

---

### RenderDoc

---

### シェーダー

#### 頂点シェーダー

頂点に作用するシェーダー
頂点数が多いほど(≒ハイポリなほど)処理に時間がかかる
画面内ではどんなに小さくても関係ない

KeyWord: LOD

---

#### フラグメントシェーダー

画面に対して作用するシェーダー
画面の画素数 × 画面に占める割合
画面内で小さいほど処理に時間がかからない

---

## まとめ

Blenderが関係あるのはポリゴン数、頂点数、テクスチャ、アニメーション

* 頂点数が多いと頂点シェーダーが重くなる
* テクスチャをたくさん使うとバッチがまとめられずドローコールが増える

だから

* LODを使う
* 頂点数を削る
* アトラス化する

---

## 次に読む/見る

* [パフォーマンスの計測 再入門 〜Unity 2020版〜(5月28日号) - Unityステーション](https://www.youtube.com/watch?v=UZ2sLiAM0oE&list=PLFw9ryLdiLzZrglM9EATbH5kb46r736Et&index=41)
  * Profilerの使い方を大体理解できる
* [メインループ マニアック解説〜これからのTime.deltaTime〜 - Unityステーション](https://www.youtube.com/watch?v=TP7N57r5Tqw&list=PLFw9ryLdiLzZrglM9EATbH5kb46r736Et&index=2)
  * UnityでCPU,GPUがどういう順序で動作するのかざっくり理解できる
* [Unity Learning Materials シェーダを理解しよう](https://learning.unity3d.jp/2042/)
  * シェーダーでどんな処理を行っているのかざっくり理解できる
* [Unity 2017最適化ガイド](https://www.amazon.co.jp/Unity-2017%E6%9C%80%E9%81%A9%E5%8C%96%E3%82%AC%E3%82%A4%E3%83%89-Unity%E3%81%AE%E3%81%82%E3%82%89%E3%82%86%E3%82%8B%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E5%95%8F%E9%A1%8C%E3%82%92%E8%A7%A3%E6%B1%BA%E3%81%99%E3%82%8B%E3%81%9F%E3%82%81%E3%81%AE%E6%89%8B%E5%BC%95%E3%81%8D-Chris-Dickinson-ebook/dp/B088K1Y4Y5)
  * コード、物理、UI、描画と広範囲の最適化方法がわかる1冊
* [公式 Unity ユーザーマニュアル](https://docs.unity3d.com/ja/2019.4/Manual/UnityManual.html)
  * 分からないところを辞書的に調べるのは良いと思う。全部読むには分量が...

---

## 参考文献

* "Chris Dickinson 著, 佐藤 敬 訳", "Unity 2017最適化ガイド: Unityのあらゆるパフォーマンス問題を解決するための手引き", 株式会社達人出版会, 2020-5
